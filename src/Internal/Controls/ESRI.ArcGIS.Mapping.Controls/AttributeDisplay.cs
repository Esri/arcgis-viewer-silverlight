/*
(c) Copyright ESRI.
This source is subject to the Microsoft Public License (Ms-PL).
Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
All other rights reserved.
*/

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Media;
using System.Windows.Threading;
using ESRI.ArcGIS.Client;
using ESRI.ArcGIS.Client.Geometry;
using ESRI.ArcGIS.Client.Toolkit;
using ESRI.ArcGIS.Mapping.Core;
using LayerExtensions = ESRI.ArcGIS.Mapping.Core.LayerExtensions;

namespace ESRI.ArcGIS.Mapping.Controls
{
    public class AttributeDisplay : ContentControl
    {
        #region Fields

        private GraphicsLayer _graphicsLayer;        
        private FieldInfo _lastSortedField = null;
        private bool _isLastSortAsc = false;
        private bool _isMapExtentChanging = false;
        private IEnumerable<Graphic> _sortedGraphics;
        private bool _fireSelectionEvent = false;
        private DispatcherTimer _refreshTimer;
        private int _refreshTimerTicks = 0;
        private volatile bool _isRefreshing = false;
        private int _refreshLastResultCount = -1;
        private bool _featureDataGridLoaded = false;

        #endregion

        public AttributeDisplay()
        {
            VerticalContentAlignment = VerticalAlignment.Stretch;
            HorizontalContentAlignment = HorizontalAlignment.Stretch;
            DefaultStyleKey = typeof(AttributeDisplay);
        }       

        private void OnFeatureDataGridSet()
        {
            if (FeatureDataGrid != null)
            {
                FeatureDataGrid.SelectionChanged -= FeatureDataGridSelectionChanged;
                FeatureDataGrid.SelectionChanged += FeatureDataGridSelectionChanged;
                FeatureDataGrid.Columns.CollectionChanged -= Columns_CollectionChanged;
                FeatureDataGrid.Columns.CollectionChanged += Columns_CollectionChanged;
                _featureDataGridLoaded = false;
                FeatureDataGrid.Loaded -= FeatureDataGrid_Loaded;
                FeatureDataGrid.Loaded += FeatureDataGrid_Loaded;
            }
            if (Content != FeatureDataGrid)
                Content = FeatureDataGrid;
            
            bindGraphicsLayerToDataGrid();
        }

        void Columns_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            if (!FeatureDataGrid.AutoGenerateColumns)
                return; //do not hide columns as these are not even added

            if (e.NewItems == null)
                return;

            FeatureLayer layer = GraphicsLayer as FeatureLayer;
            if (layer == null)
                return;

            Collection<FieldInfo> fields = LayerExtensions.GetFields(GraphicsLayer);
            if (fields == null)
                return;

            foreach(DataGridColumn column in e.NewItems)
            {
                string colName = column.Header as string;
                if (!string.IsNullOrWhiteSpace(colName))
                {
                    string fieldName = null;
                    if (layer.LayerInfo != null && layer.LayerInfo.Fields != null)
                    {
                        ESRI.ArcGIS.Client.Field field = layer.LayerInfo.Fields.FirstOrDefault(f => string.Compare(f.Alias, colName) == 0);

                        if (field == null)
                            field = layer.LayerInfo.Fields.FirstOrDefault(f => string.Compare(f.Name, colName) == 0);

                        if (field != null)
                            fieldName = field.Name;
                    }

                    FieldInfo info;
                    if (!string.IsNullOrWhiteSpace(fieldName))
                        info = fields.FirstOrDefault(f => string.Compare(f.Name, fieldName) == 0);
                    else
                    {
                        info = fields.FirstOrDefault(f => string.Compare(f.Name, colName) == 0);
                        if (info == null)
                            info = fields.FirstOrDefault(f => string.Compare(f.DisplayName, colName) == 0);
                    }

                    if (info != null)
                    {
                        column.Header = info;
                    }
                }
                ShowHideAutoGeneratedColumn(column.Header as FieldInfo);
            }
        }

        private void ShowHideAutoGeneratedColumn(FieldInfo info)
        {
            if (info == null || FeatureDataGrid == null || FeatureDataGrid.Columns == null)
                return;

            foreach (DataGridColumn column in FeatureDataGrid.Columns)
            {
                FieldInfo headerInfo = column.Header as FieldInfo;
                if (headerInfo == info)
                {
                    column.Visibility = headerInfo.VisibleInAttributeDisplay ? Visibility.Visible : Visibility.Collapsed;//show/hide the column
                    return;
                }
            }
        }

        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();

            OnFeatureDataGridSet();
        }

        private void FeatureDataGridSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            Dispatcher.BeginInvoke((Action)delegate
            {
                OnSelectionChanged(e);
            });
        }

        #region FeatureDataGrid
        /// <summary>
        /// 
        /// </summary>
        public FeatureDataGrid FeatureDataGrid
        {
            get { return GetValue(FeatureDataGridProperty) as FeatureDataGrid; }
            set { SetValue(FeatureDataGridProperty, value); }
        }

        /// <summary>
        /// Identifies the FeatureDataGrid dependency property.
        /// </summary>
        public static readonly DependencyProperty FeatureDataGridProperty =
            DependencyProperty.Register(
                "FeatureDataGrid",
                typeof(FeatureDataGrid),
                typeof(AttributeDisplay),
                new PropertyMetadata(null, OnFeatureDataGridPropertyChanged));

        /// <summary>
        /// FeatureDataGridProperty property changed handler.
        /// </summary>
        /// <param name="d">AttributeDisplay that changed its FeatureDataGrid.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnFeatureDataGridPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay source = d as AttributeDisplay;
            source.OnFeatureDataGridSet();
        }
        #endregion

        #region Map
        /// <summary>
        /// 
        /// </summary>
        public Map Map
        {
            get { return GetValue(MapProperty) as Map; }
            set { SetValue(MapProperty, value); }
        }

        /// <summary>
        /// Identifies the Map dependency property.
        /// </summary>
        public static readonly DependencyProperty MapProperty =
            DependencyProperty.Register(
                "Map",
                typeof(Map),
                typeof(AttributeDisplay),
                new PropertyMetadata(null, OnMapPropertyChanged));

        /// <summary>
        /// MapProperty property changed handler.
        /// </summary>
        /// <param name="d">AttributeDisplay that changed its Map.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnMapPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay source = d as AttributeDisplay;
            source.OnMapChanged();
        }

        internal void OnMapChanged()
        {
            if (Map != null)
            {
                Map.ExtentChanged -= MapExtentChanged;
                Map.ExtentChanged += MapExtentChanged;

                Map.ExtentChanging -= Map_ExtentChanging;
                Map.ExtentChanging += Map_ExtentChanging;
            }
        }

        void Map_ExtentChanging(object sender, ExtentEventArgs e)
        {
            _isMapExtentChanging = true;
        }
        #endregion

        #region GraphicsLayer
        /// <summary>
        /// 
        /// </summary>
        public GraphicsLayer GraphicsLayer
        {
            get { return GetValue(GraphicsLayerProperty) as GraphicsLayer; }
            set { SetValue(GraphicsLayerProperty, value); }
        }

        /// <summary>
        /// Identifies the GraphicsLayer dependency property.
        /// </summary>
        public static readonly DependencyProperty GraphicsLayerProperty =
            DependencyProperty.Register(
                "GraphicsLayer",
                typeof(GraphicsLayer),
                typeof(AttributeDisplay),
                new PropertyMetadata(null, OnGraphicsLayerPropertyChanged));

        /// <summary>
        /// GraphicsLayerProperty property changed handler.
        /// </summary>
        /// <param name="d">AttributeDisplay that changed its GraphicsLayer.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnGraphicsLayerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay source = d as AttributeDisplay;
            if (source != null)
            {
                if (e.NewValue == null && e.OldValue != null)
                {
                    source.detachHandlers();
                }
                source.SubscribeToGraphicsLayerPropertyChanged(e.OldValue as GraphicsLayer, false);
                source.OnGraphicsLayerChanged(e.NewValue as GraphicsLayer);
                source.SubscribeToGraphicsLayerPropertyChanged(e.NewValue as GraphicsLayer, true);
            }
        }

        private void SubscribeToGraphicsLayerPropertyChanged(GraphicsLayer layer, bool subscribe)
        {
            if (layer != null)
            {
                if(subscribe)
                    layer.PropertyChanged += GraphicsLayerPropertyChanged;
                else
                    layer.PropertyChanged -= GraphicsLayerPropertyChanged;
            }
        }

        internal void OnGraphicsLayerChanged(GraphicsLayer newGraphicsLayer)
        {
            detachHandlers();

            _graphicsLayer = newGraphicsLayer;
            _isLastSortAsc = false;
            _lastSortedField = null;
            _sortedGraphics = null;
            attachHandlers();

            bindGraphicsLayerToDataGrid();
        }

        private void GraphicsLayerPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e != null && e.PropertyName != null && e.PropertyName.Equals("SelectedGraphics"))
            {
                if (!_fireSelectionEvent)
                {
                    _fireSelectionEvent = true;
                    Dispatcher.BeginInvoke(() =>
                    {
                        _fireSelectionEvent = false;
                        ApplyFilterBySelection();
                    });
                }
            }
        }
        private void graphicsLayerMouseEnter(object sender, GraphicMouseEventArgs e)
        {
            if (FeatureDataGrid == null || _isMapExtentChanging)
                return;

            if (AutoScrollToGraphic)
            {
                try
                {
                    FeatureDataGrid.ScrollIntoView(e.Graphic, null);
                }
                catch
                {
                    // OK to swallow, since timing issues are common
                }
            }
        }
        #endregion

        #region AutoScrollToGraphic
        /// <summary>
        /// 
        /// </summary>
        public bool AutoScrollToGraphic
        {
            get { return (bool)GetValue(AutoScrollToGraphicProperty); }
            set { SetValue(AutoScrollToGraphicProperty, value); }
        }

        /// <summary>
        /// Identifies the AutoScrollToGraphic dependency property.
        /// </summary>
        public static readonly DependencyProperty AutoScrollToGraphicProperty =
            DependencyProperty.Register(
                "AutoScrollToGraphic",
                typeof(bool),
                typeof(AttributeDisplay),
                new PropertyMetadata(true, OnAutoScrollToGraphicPropertyChanged));

        /// <summary>
        /// AutoScrollToGraphicProperty property changed handler.
        /// </summary>
        /// <param name="d">AttributeDisplay that changed its AutoScrollToGraphic.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnAutoScrollToGraphicPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay source = d as AttributeDisplay;
            source.OnAutoScrollToGraphicChanged();
        }
        #endregion

        #region FilterFeaturesByMapExtent

        /// <summary>
        /// FilterFeaturesByMapExtent Dependency Property
        /// </summary>
        public static readonly DependencyProperty FilterFeaturesByMapExtentProperty =
            DependencyProperty.Register("FilterFeaturesByMapExtent", typeof(bool), typeof(AttributeDisplay),
                new PropertyMetadata((bool)false,
                    new PropertyChangedCallback(OnFilterFeaturesByMapExtentChanged)));

        /// <summary>
        /// Gets or sets the FilterFeaturesByMapExtent property. This dependency property 
        /// indicates ....
        /// </summary>
        public bool FilterFeaturesByMapExtent
        {
            get { return (bool)GetValue(FilterFeaturesByMapExtentProperty); }
            set { SetValue(FilterFeaturesByMapExtentProperty, value); }
        }

        /// <summary>
        /// Handles changes to the FilterFeaturesByMapExtent property.
        /// </summary>
        private static void OnFilterFeaturesByMapExtentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay display = (AttributeDisplay)d;
            bool oldFilterFeaturesByMapExtent = (bool)e.OldValue;
            bool newFilterFeaturesByMapExtent = display.FilterFeaturesByMapExtent;
            display.OnFilterFeaturesByMapExtentChanged(oldFilterFeaturesByMapExtent, newFilterFeaturesByMapExtent);
        }

        /// <summary>
        /// Provides derived classes an opportunity to handle changes to the FilterFeaturesByMapExtent property.
        /// </summary>
        protected virtual void OnFilterFeaturesByMapExtentChanged(bool oldFilterFeaturesByMapExtent, bool newFilterFeaturesByMapExtent)
        {
            sortFilterAndReBind(_isLastSortAsc, _lastSortedField);
            RaiseFilterByMapExtentChanged(EventArgs.Empty);
        }

        #endregion

        #region OverlayControl
        /// <summary>
        /// 
        /// </summary>
        public UIElement OverlayControl
        {
            get { return GetValue(AttributeDisplayControlOverlayProperty) as UIElement; }
            set { SetValue(AttributeDisplayControlOverlayProperty, value); }
        }

        /// <summary>
        /// Identifies the AttributeDisplayControlOverlay dependency property.
        /// </summary>
        public static readonly DependencyProperty AttributeDisplayControlOverlayProperty =
            DependencyProperty.Register(
                "OverlayControl",
                typeof(UIElement),
                typeof(AttributeDisplay),
                new PropertyMetadata(null));
        #endregion

        private void OnAutoScrollToGraphicChanged()
        {
            if (AutoScrollToGraphic)
            {
                if (_graphicsLayer != null)
                {
                    _graphicsLayer.MouseEnter -= graphicsLayerMouseEnter;
                    _graphicsLayer.MouseEnter += graphicsLayerMouseEnter;
                }
            }
        }

        public void Refresh()
        {
            // delay the refresh till the graphics are drawn
            Dispatcher.BeginInvoke((Action)delegate
                {
                    sortFilterAndReBind(_isLastSortAsc, _lastSortedField);
                });
            attachFieldVisiblityHandlerToGraphicsLayer();
        }

        private void MapExtentChanged(object sender, ExtentEventArgs e)
        {
            _isMapExtentChanging = false;
            if (FilterFeaturesByMapExtent &&  GraphicsLayer != null)
            {
                FeatureLayer featureLayer = GraphicsLayer as FeatureLayer;

                // Immediate refresh for non-FeatureLayers and for FeatureLayers not running OnDemand
                // Otherwise we let the update come from the layer's UpdateCompleted event
                if (featureLayer == null || (featureLayer.Mode != FeatureLayer.QueryMode.OnDemand))
                {
                    getFilterByMapExtentResultsWithRetry(_isLastSortAsc, _lastSortedField);
                }
            }
        }

        /// <summary>
        /// Finds graphics within the Envelope map area, with timer to
        /// retry every 500ms for 10 seconds
        /// </summary>
        /// <remarks>>If the timer is already running, this call will
        /// return without starting the timer.</remarks>
        /// <param name="envelope">null = entire map extent, otherwise as set</param>
        private void getFilterByMapExtentResultsWithRetry(bool isSortAsc, FieldInfo sortField, Envelope envelope= null)
        {
            if (FeatureDataGrid == null || _graphicsLayer == null || Map == null)
                return;

            if (envelope == null)
                envelope = Map.Extent;

            Dispatcher.BeginInvoke((Action)delegate
            {
                GeneralTransform transform = Transform.GetTransformToRoot(Map);
                Point ul = transform.Transform(Map.MapToScreen(new MapPoint(envelope.XMin, envelope.YMax)));
                Point lr = transform.Transform(Map.MapToScreen(new MapPoint(envelope.XMax, envelope.YMin)));
                Rect mapCoOrdinatesRect = new Rect(ul, lr);

                try
                {
                    refreshByMapExtentWithRetry(mapCoOrdinatesRect,isSortAsc,sortField);
                }
                catch (Exception ex)
                {
                    Logger.Instance.LogError(ex);
                }
            });
        }

        /// <summary>
        /// Refreshes the Attribute Display and uses a retry mechanism if the initial attempts to refresh
        /// do not return any graphics (in case the layer is large and has not fully loaded yet)
        /// </summary>
        private void refreshByMapExtentWithRetry(Rect mapExtentInHostCoordinates, bool isSortAsc, FieldInfo sortField)
        {
            try
            {
                if (_refreshTimer != null)
                {
                    _refreshTimer.Stop();
                }
                else
                {
                    _refreshTimer = new DispatcherTimer { Interval = new TimeSpan(0, 0, 0, 0, 500) };
                    _refreshTimerTicks = 0;

                    #region Timer Tick handler

                    _refreshTimer.Tick += (s, e) =>
                            {
                                if (_isRefreshing)
                                    return;

                                try
                                {
                                    _refreshTimerTicks++;
                                    // Try another refresh checking 20 times (10 seconds after the layer was added)
                                    if (_refreshTimerTicks < 20)
                                    {
                                        _isRefreshing = true;
                                        try
                                        {
                                            refreshByMapExtentNow(mapExtentInHostCoordinates,
                                                                isSortAsc, sortField, resetCount:false);
                                        }
                                        finally
                                        {
                                            _isRefreshing = false;
                                        }
                                    }
                                    else
                                    {
                                        _refreshTimer.Stop();
                                        _refreshTimer = null;
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Console.WriteLine(ex);
                                    if (_refreshTimer != null)
                                    {
                                        _refreshTimer.Stop();
                                        _refreshTimer = null;
                                    }
                                }
                            };

                    #endregion
                }

                // Attempt refresh using filter by map extent
                refreshByMapExtentNow   (mapExtentInHostCoordinates, isSortAsc, sortField);

                // The refresh did not find any graphics.  This may be due to a 
                // layer with a lot of features that has not fully loaded yet.

                _refreshTimer.Start();
            }
            catch (Exception ex2)
            {
                Console.WriteLine(ex2);
                if (_refreshTimer != null)
                {
                    _refreshTimer.Stop();
                    _refreshTimer = null;
                }
            }
        }

        /// <summary>
        /// Refreshes the Attribute Display list for graphics within the map extent
        /// </summary>
        private bool refreshByMapExtentNow(Rect mapExtentInHostCoordinates, bool isSortAsc, FieldInfo sortField, bool resetCount= true)
        {
            if (resetCount)
                _refreshLastResultCount = -1;

            try
            {
                if (mapExtentInHostCoordinates != Rect.Empty && _graphicsLayer != null)
                {
                    IEnumerable<Graphic> results = Core.Utility.FindGraphicsInHostCoordinates(_graphicsLayer, mapExtentInHostCoordinates);
                    if (results != null)
                    {
                        // load the Attribute Display with these results
                        int hitCount = results.Count();
                        // prevent the FDG from redundantly updating every time by checking the last results count
                        if (FeatureDataGrid.FilterSource == null || hitCount != _refreshLastResultCount)
                        {
                            _refreshLastResultCount = hitCount;
                            // update the feature data grid with the new results
                            applyResultsByExtentFromTimer(results, isSortAsc, sortField);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError(ex);
            }
            return false;
        }

        private void applyResultsByExtentFromTimer(IEnumerable<Graphic> results, bool isSortAsc, FieldInfo sortField)
        {
            if (results == null) return;

            // load the attribute display with the graphics within the map extent
            _sortedGraphics = SortGraphics(results, isSortAsc, sortField);
            ApplyFilterBySelection();
            CheckForAttributes();
        }

        internal IEnumerable<Graphic> GetGraphicsInViewForSelectedLayer()
        {
            if (_currentSourceBeforeSelectionFilter == null)
                return null;

            return _currentSourceBeforeSelectionFilter;
        }

        internal void SetGraphicsInViewForSelectedLayer(IEnumerable<Graphic> graphicsWithinView)
        {
            if (graphicsWithinView == null)
                return;
            IEnumerable<Graphic> sortedGraphics = graphicsWithinView;
            if (_lastSortedField != null)
            {
                if (_isLastSortAsc)
                    sortedGraphics = graphicsWithinView.OrderBy(r => r.Attributes[_lastSortedField.Name]);
                else
                    sortedGraphics = graphicsWithinView.OrderByDescending(r => r.Attributes[_lastSortedField.Name]);
            }
            _sortedGraphics = sortedGraphics;
            // display the full set of features
            ApplyFilterBySelection();
        }

        private void sortFilterAndReBind(bool isSortAsc, FieldInfo sortField)
        {
            if (FeatureDataGrid == null)
                return;

            if (_graphicsLayer == null)
                return;

            NoAttributesLabelVisibility = Visibility.Collapsed;
            if (FilterFeaturesByMapExtent)
            {
                getFilterByMapExtentResultsWithRetry(isSortAsc, sortField);
            }
            else
            {
                _sortedGraphics = SortGraphics(_graphicsLayer.Graphics, isSortAsc, sortField);
                ApplyFilterBySelection();
                CheckForAttributes();
            }
        }

        #region FilterBySelection

        /// <summary>
        /// FilterBySelection Dependency Property
        /// </summary>
        public static readonly DependencyProperty FilterBySelectionProperty =
            DependencyProperty.Register("FilterBySelection", typeof(FilterBySelectionTypeEnum), typeof(AttributeDisplay),
                new PropertyMetadata(FilterBySelectionTypeEnum.All,
                    new PropertyChangedCallback(OnFilterBySelectionChanged)));

        /// <summary>
        /// Gets or sets the FilterBySelection property. This dependency property 
        /// indicates ....
        /// </summary>
        public FilterBySelectionTypeEnum FilterBySelection
        {
            get { return (FilterBySelectionTypeEnum)GetValue(FilterBySelectionProperty); }
            set { SetValue(FilterBySelectionProperty, value); }
        }

        /// <summary>
        /// Handles changes to the FilterBySelection property.
        /// </summary>
        private static void OnFilterBySelectionChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            AttributeDisplay display = (AttributeDisplay)d;
            display.OnFilterBySelectionChanged();
        }

        /// <summary>
        /// Provides derived classes an opportunity to handle changes to the FilterBySelection property.
        /// </summary>
        protected virtual void OnFilterBySelectionChanged()
        {
            try
            {
                ApplyFilterBySelection();
                // notify the commands that the filter has changed
                RaiseFilterBySelectionChanged(EventArgs.Empty);
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError(ex);
            }
        }

        #endregion

        #region Property: HasFeatures

        /// <summary>
        /// Flag indicating the attribute display has 1 or more feature records (selected or not)
        /// </summary>
        public bool HasFeatures
        {
            get { return FeatureDataGrid != null 
                && FeatureDataGrid.GraphicsLayer != null 
                && FeatureDataGrid.GraphicsLayer.Graphics != null
                && FeatureDataGrid.GraphicsLayer.Graphics.Count() > 0; }
        }

        #endregion

        #region Check for Attributes

        private void CheckForAttributes()
        {
            bool hasAttributes = (HasFeatures && FeatureDataGrid.GraphicsLayer.Graphics[0].Attributes != null &&
                FeatureDataGrid.GraphicsLayer.Graphics[0].Attributes.Count > 0);
            NoAttributesLabelVisibility = hasAttributes ? Visibility.Collapsed : Visibility.Visible;
        }

        public Visibility NoAttributesLabelVisibility
        {
            get { return (Visibility)GetValue(NoAttributesLabelVisibilityProperty); }
            set { SetValue(NoAttributesLabelVisibilityProperty, value); }
        }

        // Using a DependencyProperty as the backing store for NoAttributesLabelVisibility.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty NoAttributesLabelVisibilityProperty =
            DependencyProperty.Register("NoAttributesLabelVisibility", typeof(Visibility), typeof(AttributeDisplay), new PropertyMetadata(Visibility.Collapsed));

        #endregion

        public Visibility NotGraphicsLayerLabelVisibility
        {
            get { return (Visibility)GetValue(NotGraphicsLayerLabelVisibilityProperty); }
            set { SetValue(NotGraphicsLayerLabelVisibilityProperty, value); }
        }

        // Using a DependencyProperty as the backing store for NotGraphicsLayerLabelVisibility.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty NotGraphicsLayerLabelVisibilityProperty =
            DependencyProperty.Register("NotGraphicsLayerLabelVisibility", typeof(Visibility), typeof(AttributeDisplay), new PropertyMetadata(Visibility.Collapsed));

        /// <summary>
        /// This applies a selection filter to the current raw (sorted) results
        /// in the FeatureDataGrid. 
        /// </summary>
        private IEnumerable<Graphic> _lastFilteredSource = null;
        private IEnumerable<Graphic> _currentSourceBeforeSelectionFilter = null;
        private Envelope _lastMapExtent = null;
        private void ApplyFilterBySelection()
        {
            // if no filter applied, just use all the graphics
            bool usingSortedGraphics = (_sortedGraphics != null);
            if (!usingSortedGraphics)
                _sortedGraphics = _graphicsLayer.Graphics;

            _currentSourceBeforeSelectionFilter = _sortedGraphics;
            try
            {
                bool applySelectionFilter = true;
                IEnumerable<Graphic> filteredSource = null;
                switch (FilterBySelection)
                {
                    case FilterBySelectionTypeEnum.Selected:
                        filteredSource = usingSortedGraphics ? _sortedGraphics.Where(graphic => graphic.Selected) : _graphicsLayer.SelectedGraphics;
                        break;
                    case FilterBySelectionTypeEnum.NotSelected:
                        filteredSource = _sortedGraphics.Where(graphic => !graphic.Selected);
                        break;
                    default: //View all graphics 
                        if (!FilterFeaturesByMapExtent)//filter by map extent is off, so there is no need to apply filter source at all
                            applySelectionFilter = false;
                        else //filter by map extent is on, so check last extent and last number of graphics. Last extent is checked in order to reduce the
                             //number of collection comparisons, which might get really expensive.
                        {
                            if (_lastMapExtent != null && _lastMapExtent.Equals(Map.Extent) && _lastFilteredSource != null && _sortedGraphics != null && _lastFilteredSource.Count() == _sortedGraphics.Count())
                            {
                                var diff = _lastFilteredSource.Intersect(_sortedGraphics);
                                if (diff != null && diff.Count() == _lastFilteredSource.Count())
                                    applySelectionFilter = false; //TODO - timer causes many hits on this line - optimize further
                                else
                                    filteredSource = _sortedGraphics;
                            }
                            else
                                filteredSource = _sortedGraphics;
                        }
                        break;
                }

                if (applySelectionFilter)
                {
                    //
                    //TODO Start: This is a workaround for a bug in Core API where sorted column descriptions are lost when Filter Source is applied
                    //
                    SortDescriptionCollection sortDescs = null;
                    PagedCollectionView view = FeatureDataGrid.ItemsSource as PagedCollectionView;
                    if (view != null)
                        sortDescs = view.SortDescriptions;

                    //This is needed in the case there are no sort descriptions (when data is not ordered by attribute)
                    //as when filteredSource is set in that case, it re-arranges the order of items according to itself,
                    //rather than the order of graphics in the graphics layer
                    if (sortDescs == null || (sortDescs != null && sortDescs.Count == 0))
                    {
                        List<Graphic> sorted = filteredSource != null ? filteredSource.ToList() : null;
                        if (sorted != null)
                        {
                            sorted.Sort(SortByDefaultOrder);
                            filteredSource = sorted;
                        }
                    }
                    //
                    //TODO End: This is a workaround for a bug in Core API where sorted column descriptions are lost when Filter Source is applied
                    //

                    // Assign the filtered set to the datagrid
                    FeatureDataGrid.FilterSource = filteredSource;
                    _lastFilteredSource = filteredSource;
                    _lastMapExtent = Map.Extent;
                    //
                    //TODO Start: This is a workaround for a bug in Core API where sorted column is lost when Filter Source is applied
                    //
                    if (sortDescs != null)
                    {
                        view = FeatureDataGrid.ItemsSource as PagedCollectionView;
                        if (view != null && (view.SortDescriptions == null || (view.SortDescriptions != null && view.SortDescriptions.Count == 0)))
                        {
                            foreach (SortDescription desc in sortDescs)
                                view.SortDescriptions.Add(desc);
                        }
                    }
                    //
                    //TODO End: This is a workaround for a bug in Core API where sorted column is lost when Filter Source is applied
                    //
                }
                else if (!FilterFeaturesByMapExtent)// if filter by map extent is not on and we are in view All graphics mode, 
                    //then no point to have a filter source set whatsoever
                    {
                        FeatureDataGrid.FilterSource = null;
                        _lastFilteredSource = null;
                }
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError(ex);
            }
        }


        private int SortByDefaultOrder(Graphic x, Graphic y)
        {
            if (x == null || y == null)
                return 0;

            if (FeatureDataGrid == null)
                return 0;

            if (FeatureDataGrid.GraphicsLayer == null)
                return 0;

            int indexX = FeatureDataGrid.GraphicsLayer.Graphics.IndexOf(x);
            int indexY = FeatureDataGrid.GraphicsLayer.Graphics.IndexOf(y);

            if (indexX == indexY)
                return 0;
            else
                return indexX > indexY ? 1 : -1;
        }




        internal IEnumerable<Graphic> SortGraphics(IEnumerable<Graphic> graphics, bool isSortAsc, FieldInfo sortField)
        {
            if (sortField != null)
            {
                bool sortable = false;
                Type dataType = null;
                foreach (Graphic graphic in graphics)
                {
                    if (graphic.Attributes[sortField.Name] != null)
                    {
                        sortable = graphic.Attributes[sortField.Name] is IComparable;
                        dataType = graphic.Attributes[sortField.Name].GetType();
                        break;
                    }
                }
                if (sortable && dataType != null)
                {
                    if (isSortAsc)
                        graphics = graphics.OrderBy(r => (
                             (r.Attributes[sortField.Name] != null && r.Attributes[sortField.Name].GetType() == dataType) ?
                             r.Attributes[sortField.Name] : null));
                    else
                        graphics = graphics.OrderByDescending(r => (
                             (r.Attributes[sortField.Name] != null && r.Attributes[sortField.Name].GetType() == dataType) ?
                             r.Attributes[sortField.Name] : null));
                }
            }
            return graphics;
        }

        private void detachFieldVisibilityHandlerFromGraphicsLayer()
        {
            if (_graphicsLayer == null)
                return;

            Collection<FieldInfo> fields = LayerExtensions.GetFields(_graphicsLayer);
            if (fields != null)
            {
                foreach (FieldInfo field in fields)
                {
                    field.PropertyChanged -= fieldPropertyChanged;
                }
            }
        }

        private void detachMouseHandlerFromGraphicsLayer()
        {
            if (_graphicsLayer == null)
                return;

            if (AutoScrollToGraphic)
                _graphicsLayer.MouseEnter -= graphicsLayerMouseEnter;
        }

        private void detachHandlers()
        {
            var oldLayer = GraphicsLayer as FeatureLayer;
            if (oldLayer != null)
                oldLayer.UpdateCompleted -= featureLayer_UpdateCompleted;

            detachFieldVisibilityHandlerFromGraphicsLayer();

            detachMouseHandlerFromGraphicsLayer();
        }

        private void attachHandlers()
        {
            FeatureLayer featureLayer = GraphicsLayer as FeatureLayer;
            if (featureLayer != null)
            {
                featureLayer.UpdateCompleted -= featureLayer_UpdateCompleted;
                featureLayer.UpdateCompleted += featureLayer_UpdateCompleted;
            }

            attachFieldVisiblityHandlerToGraphicsLayer();

            attachMouseHandlerToGraphicsLayer();
        }

        private void attachFieldVisiblityHandlerToGraphicsLayer()
        {
            if (_graphicsLayer == null)
                return;

            Collection<FieldInfo> fields = LayerExtensions.GetFields(_graphicsLayer);
            if (fields != null)
            {
                foreach (FieldInfo field in fields)
                {
                    field.PropertyChanged -= fieldPropertyChanged;
                    field.PropertyChanged += fieldPropertyChanged;
                }
            }
        }

        private void attachMouseHandlerToGraphicsLayer()
        {
            if (_graphicsLayer == null)
                return;

            if (AutoScrollToGraphic)
                _graphicsLayer.MouseEnter += graphicsLayerMouseEnter;
        }

        public void ClearAllFields()
        {
            if (FeatureDataGrid == null)
                return;

            FeatureDataGrid.Columns.Clear();
        }

        private void bindGraphicsLayerToDataGrid()
        {
            if (FeatureDataGrid == null)
                return;

            FeatureDataGrid.GraphicsLayer = null; //make sure we disconnect the current graphics layer from the feature grid
            //because clearing the columns causes SelectionChanged event which removes layers selection
            FeatureDataGrid.Columns.Clear();

            if (GraphicsLayer == null)
            {
                // if not graphics layer, display not graphics label
                NoAttributesLabelVisibility = Visibility.Collapsed;
                NotGraphicsLayerLabelVisibility = Visibility.Visible;

                // Associate dummy graphics layer to avoid null ref exception thrown by core API
                FeatureDataGrid.GraphicsLayer = new GraphicsLayer(); 

                // Nothing more to do
                return;
            }
            else
                NotGraphicsLayerLabelVisibility = Visibility.Collapsed;

            FeatureLayer fLayer = GraphicsLayer as FeatureLayer;
            if (fLayer != null && !string.IsNullOrEmpty(fLayer.Url)) // Feature layer with empty URL is a feature collection
            {
                FeatureDataGrid.AutoGenerateColumns = true;
            }
            else
            {
                if (!_featureDataGridLoaded)
                    //Generating columns is delayed because of a bug in the DataGrid (bug 4070)
                    FeatureDataGrid.AutoGenerateColumns = true;
                else
                {
                    FeatureDataGrid.AutoGenerateColumns = false;
                    AddColumns();
                }
            }

            if (FilterFeaturesByMapExtent)
            {
                if (Map != null)
                {
                    if (GraphicsLayer.IsInitialized && (bool)GraphicsLayer.GetValue(ESRI.ArcGIS.Client.Extensibility.LayerExtensions.InitialUpdateCompletedProperty))
                    {
                        FeatureDataGrid.GraphicsLayer = GraphicsLayer;
                        getFilterByMapExtentResultsWithRetry(_isLastSortAsc, _lastSortedField);
                    }
                    else
                    {
                        // It is a new layer, we cannot filter right away because the graphics are not drawn
                        RefreshAfterDrawComplete();
                    }
                }
            }
            else
            {
                _sortedGraphics = null;
                FeatureDataGrid.FilterSource = null;
                FeatureDataGrid.GraphicsLayer = GraphicsLayer;
                FilterBySelection = FilterBySelectionTypeEnum.All;
            }
            CheckForAttributes();
        }

        private void AddColumns()
        {
            Collection<FieldInfo> fields = LayerExtensions.GetFields(GraphicsLayer);
            if (fields != null)
            {
                foreach (FieldInfo field in fields)
                {
                    if (!field.VisibleInAttributeDisplay)
                        continue;

                    CustomDataGridColumn col = createDataGridColumnForField(field);
                    FeatureDataGrid.Columns.Add(col);
                }
            }
        }

        private void FeatureDataGrid_Loaded(object sender, RoutedEventArgs e)
        {
            if (!_featureDataGridLoaded)
            {
                _featureDataGridLoaded = true;

                FeatureLayer fLayer = GraphicsLayer as FeatureLayer;
                if (GraphicsLayer == null || (fLayer != null && !string.IsNullOrEmpty(fLayer.Url)))
                    return;

                FeatureDataGrid.AutoGenerateColumns = false;
                AddColumns();
            }
        }

        private void featureLayer_UpdateCompleted(object sender, EventArgs e)
        {
            Dispatcher.BeginInvoke((Action)delegate
            {
                sortFilterAndReBind(_isLastSortAsc, _lastSortedField);
            });
        }

        internal void RefreshAfterDrawComplete()
        {
            FeatureDataGrid.GraphicsLayer = GraphicsLayer;
            ApplyFilterBySelection();

            FeatureLayer featureLayer = GraphicsLayer as FeatureLayer;
            if (featureLayer != null)
            {
                featureLayer.UpdateCompleted -= featureLayer_UpdateCompleted;
                featureLayer.UpdateCompleted += featureLayer_UpdateCompleted;
            }
            else
            {
                ICustomGraphicsLayer customGraphicsLayer = GraphicsLayer as ICustomGraphicsLayer;
                if (customGraphicsLayer != null)
                {
                    customGraphicsLayer.UpdateCompleted -= customGraphicsLayer_UpdateCompleted;
                    customGraphicsLayer.UpdateCompleted += customGraphicsLayer_UpdateCompleted;
                }
            }
        }

        private void customGraphicsLayer_UpdateCompleted(object sender, EventArgs e)
        {
            Dispatcher.BeginInvoke((Action)delegate
            {
                sortFilterAndReBind(_isLastSortAsc, _lastSortedField);
            });
        }


        private bool doesfieldNeedNormalization(string fieldName)
        {
            return fieldName != null && (fieldName.IndexOf("/", StringComparison.Ordinal) > -1);
        }

        private string normalizeFieldName(string fieldName)
        {
            if (string.IsNullOrEmpty(fieldName))
                return fieldName;

            return fieldName.Replace('/', '_');
        }

        private void fieldPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            FieldInfo field = sender as FieldInfo;
            if (field == null)
                return;

            if (e.PropertyName != "VisibleInAttributeDisplay")
                // we are only interested in property changes where attribute display is changed
                return;

            if (FeatureDataGrid == null)
                return;

            if (FeatureDataGrid.AutoGenerateColumns)
            {
                ShowHideAutoGeneratedColumn(field);
            }
            else
            {
                if (!field.VisibleInAttributeDisplay)
                {
                    // removing field
                    CustomDataGridColumn column = getColumnForField(field.Name);
                    if (column != null)
                        FeatureDataGrid.Columns.Remove(column);
                }
                else
                {
                    // adding field
                    CustomDataGridColumn col = createDataGridColumnForField(field);
                    int pos = findInsertIndexOfField(field);
                    if (pos < FeatureDataGrid.Columns.Count)
                        FeatureDataGrid.Columns.Insert(pos, col);
                    else
                        FeatureDataGrid.Columns.Add(col);
                }
            }
        }

        private CustomDataGridColumn createDataGridColumnForField(FieldInfo field)
        {
            string fieldName = field.Name;
            if (doesfieldNeedNormalization(fieldName))
            {
                fieldName = normalizeFieldName(fieldName);
            }

            CustomDataGridColumn col = new CustomDataGridColumn()
            {
                Header = field,
                IsReadOnly = true,
                Binding = new Binding()
                {
                    // Use a converter to retrieve the field value.  Otherwise, the binding
                    // will blow up on field names that are numeric - and perhaps others
                    Converter = new RowToFieldValueConverter(),
                    ConverterParameter = fieldName
                },
                FieldInfo = field,
            };
            return col;
        }

        private int findInsertIndexOfField(FieldInfo field)
        {
            int pos = 0;
            Collection<FieldInfo> fields = LayerExtensions.GetFields(GraphicsLayer);
            if (fields != null)
            {
                foreach (FieldInfo f in fields)
                {
                    if (f.Name == field.Name)
                        break;
                    if (!f.VisibleInAttributeDisplay) // skip non visible fields
                        continue;
                    pos++;
                }
            }
            return pos;
        }

        CustomDataGridColumn getColumnForField(string fieldName)
        {
            if (FeatureDataGrid == null || string.IsNullOrEmpty(fieldName))
                return null;
            foreach (DataGridColumn column in FeatureDataGrid.Columns)
            {
                CustomDataGridColumn textColumn = column as CustomDataGridColumn;
                if (textColumn != null)
                {
                    string colName = textColumn.FieldInfo.Name;
                    if (fieldName.Equals(colName) || normalizeFieldName(fieldName).Equals(colName))
                        return textColumn;
                }
            }
            return null;
        }

        internal void RaiseSortedEvent(FieldInfo fieldInfo)
        {
            bool isSortAsc = _lastSortedField == fieldInfo ? !_isLastSortAsc : true;

            sortFilterAndReBind(isSortAsc, fieldInfo);

            _isLastSortAsc = isSortAsc;
            _lastSortedField = fieldInfo;

            OnSorted(new DataGridSortedEventArgs() { SortedField = fieldInfo });
        }

        protected virtual void OnSelectionChanged(SelectionChangedEventArgs args)
        {
            if (SelectionChanged != null)
                SelectionChanged(this, args);
        }

        protected virtual void RaiseFilterBySelectionChanged(EventArgs args)
        {
            if (FilterBySelectionChanged != null)
                FilterBySelectionChanged(this, args);
        }

        protected virtual void RaiseFilterByMapExtentChanged(EventArgs args)
        {
            if (FilterByMapExtentChanged != null)
                FilterByMapExtentChanged(this, args);
        }

        protected virtual void OnSorted(DataGridSortedEventArgs args)
        {
            if (Sorted != null)
                Sorted(this, args);
        }

        /// <summary>
        /// Attribute display filter type
        /// </summary>
        public enum FilterBySelectionTypeEnum
        {
            All,
            Selected,
            NotSelected
        }

        public event EventHandler<DataGridSortedEventArgs> Sorted;
        public event EventHandler<SelectionChangedEventArgs> SelectionChanged;
        public event EventHandler FilterBySelectionChanged;
        public event EventHandler FilterByMapExtentChanged;
    }

    public class DataGridSortedEventArgs : EventArgs
    {
        public FieldInfo SortedField { get; set; }
    }
}
